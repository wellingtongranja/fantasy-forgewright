/**
 * ExportManager - Document export functionality for Fantasy Editor
 * Supports multiple formats with theme-aware styling
 */

export class ExportManager {
  constructor(app) {
    this.app = app
    this.supportedFormats = ['md', 'txt', 'html', 'pdf']
  }

  /**
   * Export current document in specified format
   */
  async exportDocument(format, options = {}) {
    const doc = this.app.currentDocument
    if (!doc) {
      throw new Error('No document currently open')
    }

    const content = this.app.editor.getContent()
    const title = doc.title || 'Untitled Document'
    const stats = this.app.editor.getDocumentStats()

    switch (format.toLowerCase()) {
      case 'md':
      case 'markdown':
        return this.exportAsMarkdown(title, content, doc, options)

      case 'txt':
      case 'text':
        return this.exportAsText(title, content, doc, options)

      case 'html':
        return await this.exportAsHTML(title, content, doc, stats, options)

      case 'pdf':
        return this.exportAsPDF(title, content, doc, stats, options)

      default:
        throw new Error(`Unsupported export format: ${format}`)
    }
  }

  /**
   * Export as Markdown with metadata
   */
  exportAsMarkdown(title, content, doc, options = {}) {
    let output = ''

    // Add frontmatter if requested
    if (options.includeFrontmatter !== false) {
      output += '---\n'
      output += `title: "${title}"\n`
      output += `created: ${doc.createdAt || new Date().toISOString()}\n`
      output += `updated: ${doc.updatedAt || new Date().toISOString()}\n`

      if (doc.tags && doc.tags.length > 0) {
        output += `tags: [${doc.tags.map((tag) => `"${tag}"`).join(', ')}]\n`
      }

      if (doc.id) {
        output += `id: "${doc.id}"\n`
      }

      output += '---\n\n'
    }

    output += content

    return this.downloadFile(`${title}.md`, output, 'text/markdown')
  }

  /**
   * Export as plain text
   */
  exportAsText(title, content, doc, options = {}) {
    // Convert markdown to plain text
    let plainText = content
      .replace(/^#{1,6}\s+(.+)$/gm, '$1') // Remove heading markers
      .replace(/\*\*(.+?)\*\*/g, '$1') // Remove bold markers
      .replace(/\*(.+?)\*/g, '$1') // Remove italic markers
      .replace(/~~(.+?)~~/g, '$1') // Remove strikethrough
      .replace(/`(.+?)`/g, '$1') // Remove code markers
      .replace(/\[(.+?)\]\(.+?\)/g, '$1') // Convert links to text
      .replace(/^\s*[-*+]\s+/gm, '• ') // Convert lists to bullets
      .replace(/^\s*\d+\.\s+/gm, '• ') // Convert numbered lists to bullets

    // Add metadata header if requested
    if (options.includeMetadata !== false) {
      let header = `${title}\n`
      header += '='.repeat(title.length) + '\n\n'

      if (doc.createdAt) {
        header += `Created: ${new Date(doc.createdAt).toLocaleDateString()}\n`
      }
      if (doc.updatedAt) {
        header += `Updated: ${new Date(doc.updatedAt).toLocaleDateString()}\n`
      }
      if (doc.tags && doc.tags.length > 0) {
        header += `Tags: ${doc.tags.join(', ')}\n`
      }

      header += '\n' + '-'.repeat(40) + '\n\n'
      plainText = header + plainText
    }

    return this.downloadFile(`${title}.txt`, plainText, 'text/plain')
  }

  /**
   * Export as HTML with theme styling
   */
  async exportAsHTML(title, content, doc, stats, options = {}) {
    const theme = this.app.themeManager.getCurrentTheme()
    const htmlContent = await this.markdownToHTML(content)

    const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(title)}</title>
    <style>
        ${this.getExportCSS(theme)}
    </style>
</head>
<body class="theme-${theme}">
    <div class="document">
        <header class="document-header">
            <h1 class="document-title">${this.escapeHtml(title)}</h1>
            <div class="document-meta">
                ${doc.createdAt ? `<p>Created: ${new Date(doc.createdAt).toLocaleDateString()}</p>` : ''}
                ${doc.updatedAt ? `<p>Updated: ${new Date(doc.updatedAt).toLocaleDateString()}</p>` : ''}
                ${stats ? `<p>Words: ${stats.words} • Characters: ${stats.characters}</p>` : ''}
                ${doc.tags && doc.tags.length > 0 ? `<p>Tags: ${doc.tags.join(', ')}</p>` : ''}
            </div>
        </header>
        
        <main class="document-content">
            ${htmlContent}
        </main>
        
        <footer class="document-footer">
            <p>Generated by <a href="https://forgewright.io">Fantasy Editor</a></p>
        </footer>
    </div>
</body>
</html>`

    return this.downloadFile(`${title}.html`, html, 'text/html')
  }

  /**
   * Export as PDF using jsPDF library
   */
  async exportAsPDF(title, content, doc, stats, options = {}) {
    try {
      // Dynamically import jsPDF
      const { jsPDF } = await import('jspdf')

      // Create new PDF document
      const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a4'
      })

      // Set font
      pdf.setFont('helvetica')

      // Document title
      pdf.setFontSize(18)
      pdf.setFont('helvetica', 'bold')
      pdf.text(title, 20, 30)

      // Document metadata
      let yPosition = 50
      pdf.setFontSize(10)
      pdf.setFont('helvetica', 'normal')

      if (doc.createdAt) {
        pdf.text(`Created: ${new Date(doc.createdAt).toLocaleDateString()}`, 20, yPosition)
        yPosition += 6
      }

      if (stats) {
        pdf.text(`Words: ${stats.words} • Characters: ${stats.characters}`, 20, yPosition)
        yPosition += 6
      }

      if (doc.tags && doc.tags.length > 0) {
        pdf.text(`Tags: ${doc.tags.join(', ')}`, 20, yPosition)
        yPosition += 6
      }

      // Add separator line
      yPosition += 10
      pdf.line(20, yPosition, 190, yPosition)
      yPosition += 15

      // Convert markdown to plain text for PDF
      const plainText = this.markdownToPlainText(content)

      // Split text into lines that fit the page width
      pdf.setFontSize(11)
      pdf.setFont('helvetica', 'normal')

      const pageWidth = 170 // PDF width minus margins
      const lineHeight = 6
      const lines = pdf.splitTextToSize(plainText, pageWidth)

      // Add text to PDF with page breaks
      const pageHeight = 270 // A4 height minus margins

      for (let i = 0; i < lines.length; i++) {
        if (yPosition > pageHeight) {
          pdf.addPage()
          yPosition = 30
        }

        pdf.text(lines[i], 20, yPosition)
        yPosition += lineHeight
      }

      // Generate and download PDF
      const pdfBlob = pdf.output('blob')
      const url = URL.createObjectURL(pdfBlob)

      const link = document.createElement('a')
      link.href = url
      link.download = `${title}.pdf`
      link.style.display = 'none'

      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)

      // Clean up
      setTimeout(() => URL.revokeObjectURL(url), 100)

      return {
        success: true,
        message: `Downloaded ${title}.pdf`,
        filename: `${title}.pdf`
      }
    } catch (error) {
      console.error('PDF export failed:', error)
      return {
        success: false,
        message: `PDF export failed: ${error.message}`
      }
    }
  }

  /**
   * Convert markdown to plain text for PDF export
   */
  markdownToPlainText(markdown) {
    return (
      markdown
        // Remove headers markers but keep text
        .replace(/^#{1,6}\s+(.+)$/gm, '$1')

        // Remove bold/italic markers
        .replace(/\*\*\*(.+?)\*\*\*/g, '$1')
        .replace(/\*\*(.+?)\*\*/g, '$1')
        .replace(/\*(.+?)\*/g, '$1')

        // Remove strikethrough
        .replace(/~~(.+?)~~/g, '$1')

        // Remove code markers
        .replace(/`(.+?)`/g, '$1')
        .replace(/```[\s\S]*?```/g, (match) => {
          return match.slice(3, -3).trim()
        })

        // Convert links to text with URL
        .replace(/\[(.+?)\]\((.+?)\)/g, '$1 ($2)')

        // Convert lists to simple bullet points
        .replace(/^\s*[-*+]\s+/gm, '• ')
        .replace(/^\s*\d+\.\s+/gm, '• ')

        // Clean up extra whitespace
        .replace(/\n\s*\n/g, '\n\n')
        .trim()
    )
  }

  /**
   * Convert markdown to HTML (basic implementation)
   */
  async markdownToHTML(markdown) {
    let html = markdown
      // Headers
      .replace(/^### (.*$)/gm, '<h3>$1</h3>')
      .replace(/^## (.*$)/gm, '<h2>$1</h2>')
      .replace(/^# (.*$)/gm, '<h1>$1</h1>')

      // Bold and italic
      .replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>')
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>')

      // Strikethrough
      .replace(/~~(.+?)~~/g, '<del>$1</del>')

      // Code
      .replace(/`(.+?)`/g, '<code>$1</code>')

      // Links
      .replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2">$1</a>')

      // Lists
      .replace(/^\s*\* (.+)$/gm, '<li>$1</li>')
      .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')

      // Paragraphs (simple implementation)
      .replace(/^\n(.+)$/gm, '<p>$1</p>')

      // Line breaks
      .replace(/\n/g, '<br>')

    // Dynamically import DOMPurify
    const DOMPurify = (await import('dompurify')).default
    return DOMPurify.sanitize(html)
  }

  /**
   * Get CSS for HTML exports
   */
  getExportCSS(theme) {
    const baseCSS = `
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        line-height: 1.6;
        max-width: 65ch;
        margin: 2rem auto;
        padding: 2rem;
        color: #333;
        background: #fff;
      }
      
      .document-header {
        border-bottom: 2px solid #eee;
        padding-bottom: 1rem;
        margin-bottom: 2rem;
      }
      
      .document-title {
        margin: 0;
        font-size: 2.5rem;
        font-weight: bold;
      }
      
      .document-meta {
        margin-top: 1rem;
        font-size: 0.9rem;
        color: #666;
      }
      
      .document-meta p {
        margin: 0.25rem 0;
      }
      
      .document-content h1,
      .document-content h2,
      .document-content h3 {
        margin-top: 2rem;
        margin-bottom: 1rem;
      }
      
      .document-content p {
        margin: 1rem 0;
      }
      
      .document-content code {
        background: #f5f5f5;
        padding: 0.2rem 0.4rem;
        border-radius: 3px;
        font-family: 'SF Mono', Monaco, Consolas, monospace;
      }
      
      .document-footer {
        margin-top: 3rem;
        padding-top: 1rem;
        border-top: 1px solid #eee;
        text-align: center;
        font-size: 0.8rem;
        color: #888;
      }
    `

    const themeCSS = {
      dark: `
        body { background: #1a1a1a; color: #e0e0e0; }
        .document-header { border-bottom-color: #333; }
        .document-meta { color: #999; }
        .document-footer { border-top-color: #333; color: #666; }
        .document-content code { background: #2a2a2a; }
      `,
      fantasy: `
        body { 
          background: linear-gradient(135deg, #f5f3f0 0%, #e8e5e0 100%); 
          color: #2c1810;
          font-family: 'Crimson Text', serif;
        }
        .document-title { color: #8b4513; }
        .document-header { border-bottom-color: #d4c4a0; }
        .document-content h1, .document-content h2, .document-content h3 { 
          color: #8b4513; 
        }
      `
    }

    return baseCSS + (themeCSS[theme] || '')
  }

  /**
   * Get CSS optimized for printing
   */
  getPrintCSS(theme) {
    return `
      @page {
        margin: 1in;
        size: letter;
      }
      
      body {
        font-family: 'Times New Roman', serif;
        font-size: 12pt;
        line-height: 1.5;
        color: #000;
        background: #fff !important;
      }
      
      .document-header {
        page-break-after: avoid;
        border-bottom: 2pt solid #000;
        padding-bottom: 12pt;
        margin-bottom: 24pt;
      }
      
      .document-title {
        font-size: 18pt;
        font-weight: bold;
        margin: 0;
      }
      
      .document-meta {
        font-size: 10pt;
        margin-top: 6pt;
      }
      
      .document-content h1 {
        font-size: 16pt;
        page-break-after: avoid;
        margin-top: 24pt;
        margin-bottom: 12pt;
      }
      
      .document-content h2 {
        font-size: 14pt;
        page-break-after: avoid;
        margin-top: 18pt;
        margin-bottom: 10pt;
      }
      
      .document-content h3 {
        font-size: 12pt;
        page-break-after: avoid;
        margin-top: 15pt;
        margin-bottom: 8pt;
      }
      
      .document-content p {
        margin: 6pt 0;
        orphans: 3;
        widows: 3;
      }
      
      .document-content code {
        font-family: 'Courier New', monospace;
        background: #f8f8f8;
        padding: 2pt;
      }
      
      a {
        color: #000;
        text-decoration: underline;
      }
      
      @media print {
        body { print-color-adjust: exact; }
        .document-footer { page-break-inside: avoid; }
      }
    `
  }

  /**
   * Download file with given content
   */
  downloadFile(filename, content, mimeType) {
    const blob = new Blob([content], { type: mimeType })
    const url = URL.createObjectURL(blob)

    const link = document.createElement('a')
    link.href = url
    link.download = filename
    link.style.display = 'none'

    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)

    // Clean up object URL
    setTimeout(() => URL.revokeObjectURL(url), 100)

    return {
      success: true,
      message: `Downloaded ${filename}`,
      filename
    }
  }

  /**
   * Escape HTML characters
   */
  escapeHtml(unsafe) {
    return unsafe
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;')
  }

  /**
   * Get supported export formats
   */
  getSupportedFormats() {
    return [...this.supportedFormats]
  }

  /**
   * Validate export format
   */
  isFormatSupported(format) {
    return this.supportedFormats.includes(format.toLowerCase())
  }
}
